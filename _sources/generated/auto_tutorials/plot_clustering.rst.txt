
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated/auto_tutorials/plot_clustering.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_generated_auto_tutorials_plot_clustering.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_auto_tutorials_plot_clustering.py:


Clustering
===========================

This tutorial aims to explain and visualize the use of the clustering
algorithms implemented in the package.

.. GENERATED FROM PYTHON SOURCE LINES 9-21

Introduction
-------------

Clustering is a form of unsupervised learning where data samples are grouped
in clusters by using some metric of similarity between the samples.

In this package, the two algorithms implemented are distance-based. This
means that the similarity measure being used to group the samples is
the Euclidean distance or L2-norm.

The distances in the algorithms can be computed classically or estimated
with a quantum subroutine.

.. GENERATED FROM PYTHON SOURCE LINES 24-26

In order to represent the cluster assignments, a utility function is defined
that plots the data assignments as well as the center of each cluster.

.. GENERATED FROM PYTHON SOURCE LINES 26-42

.. code-block:: default


    from skqlearn.utils import JobHandler
    from skqlearn.clustering import *
    import matplotlib.pyplot as plt
    import numpy as np
    from qiskit.providers.aer import AerSimulator
    from sklearn.datasets import make_blobs


    def plot_cluster(axis, x, labels, centers):
        for y in np.unique(labels):
            members = labels == y
            axis.scatter(x[members, 0], x[members, 1])
            axis.scatter(centers[y, 0], centers[y, 1], s=[100], marker='X')









.. GENERATED FROM PYTHON SOURCE LINES 43-45

Because the tutorial will also test the quantum distance estimation
algorithm, the quantum backend must be configured.

.. GENERATED FROM PYTHON SOURCE LINES 45-48

.. code-block:: default


    JobHandler().configure(backend=AerSimulator(), shots=50000)








.. GENERATED FROM PYTHON SOURCE LINES 49-50

First, random data is generated centered around two points.

.. GENERATED FROM PYTHON SOURCE LINES 50-59

.. code-block:: default


    np.random.seed(0)
    centers = np.array([[0, 0], [0, 1]])
    n_clusters = centers.shape[0]
    x, labels = make_blobs(n_samples=10, centers=centers, cluster_std=0.25)

    plot_cluster(plt, x, labels, centers)
    plt.show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_clustering_001.png
   :alt: plot clustering
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_clustering_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 60-70

KMeans
--------

The implementation of the KMeans algorithm is based on an iterative
refinement technique. The cluster centers are initially chosen at random
between the trainging data. After that, the algorithm assigns each data
sample to the closest centroid (cluster center) and recalculates the centroid
as the mean of all sample data assigned to it. This process is repeated until
there is no change of assignments between two iterations or the iteration
limit is reached.

.. GENERATED FROM PYTHON SOURCE LINES 72-78

The first step will be to train the algorithm with the data samples. During
the training, the values for the centroids are stored in the object, as well
as the final labels/assignments for the data samples. This allows us to
see how the algorithm has decided to cluster the data samples. The distance
calculation method can be provided in the constructor of the class, in order
to choose between the classic and quantum calculations.

.. GENERATED FROM PYTHON SOURCE LINES 78-103

.. code-block:: default


    k_means_classic = KMeans(n_clusters=len(centers),
                             max_iterations=20,
                             random_state=0,
                             distance_calculation_method='classic')
    k_means_classic.fit(x)

    k_means_quantum = KMeans(n_clusters=len(centers),
                             max_iterations=20,
                             random_state=0,
                             distance_calculation_method='quantum')
    k_means_quantum.fit(x)

    fig, (ax1, ax2) = plt.subplots(1, 2)
    fig.suptitle('KMeans')
    ax1.set_title('Classic')
    ax2.set_title('Quantum')

    plot_cluster(ax1, x, k_means_classic.labels,
                 k_means_classic.cluster_centers)
    plot_cluster(ax2, x, k_means_quantum.labels,
                 k_means_quantum.cluster_centers)

    plt.show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_clustering_002.png
   :alt: KMeans, Classic, Quantum
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_clustering_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 104-106

The trained estimators can then be used to assign new data to the current
clusters by using the `predict` method.

.. GENERATED FROM PYTHON SOURCE LINES 106-110

.. code-block:: default


    new_data = np.array([[-1, 0], [0, 2]])
    print(k_means_classic.predict(new_data))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0 1]




.. GENERATED FROM PYTHON SOURCE LINES 111-123

KMedians
--------

KMedians follows the same structure as KMeans. The only difference between
the two algorithms is how the centroids are updated after every iteration.
In KMedians, the centroid is calculated as the median of all data samples
assigned to it, with the median being defined as the sample that minimizes
the distance to all other samples:

.. math::
   arg\,min_{\boldsymbol{x}_j}\sum_{i=1}^m||\boldsymbol{x}_i -
   \boldsymbol{x}_j||_{2}

.. GENERATED FROM PYTHON SOURCE LINES 123-147

.. code-block:: default


    k_medians_classic = KMedians(n_clusters=len(centers),
                                 max_iterations=20,
                                 random_state=0,
                                 distance_calculation_method='classic')
    k_medians_classic.fit(x)

    k_medians_quantum = KMedians(n_clusters=len(centers),
                                 max_iterations=20,
                                 random_state=0,
                                 distance_calculation_method='quantum')
    k_medians_quantum.fit(x)

    fig, (ax1, ax2) = plt.subplots(1, 2)
    fig.suptitle('KMedians')
    ax1.set_title('Classic')
    ax2.set_title('Quantum')

    plot_cluster(ax1, x, k_medians_classic.labels,
                 k_medians_classic.cluster_centers)
    plot_cluster(ax2, x, k_medians_quantum.labels,
                 k_medians_quantum.cluster_centers)

    plt.show()



.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_clustering_003.png
   :alt: KMedians, Classic, Quantum
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_clustering_003.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  34.850 seconds)


.. _sphx_glr_download_generated_auto_tutorials_plot_clustering.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_clustering.py <plot_clustering.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_clustering.ipynb <plot_clustering.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
