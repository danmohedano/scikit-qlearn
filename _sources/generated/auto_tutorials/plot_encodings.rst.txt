
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated/auto_tutorials/plot_encodings.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_generated_auto_tutorials_plot_encodings.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_auto_tutorials_plot_encodings.py:


.. _encodingstutorial:

Data Encodings
===========================

This tutorial aims to explain and visualize the different data encoding methods
implemented in the package.

.. GENERATED FROM PYTHON SOURCE LINES 12-84

Introduction
-------------

Machine Learning algorithms rely on sample data in order to train and learn.
When trying to enhance these algorithms with quantum subroutines, the first
issue one can encounter is how to translate the classical sample data into
a format that can be understood by a quantum machine.

While classical computers' most basic unit of information is the bit, quantum
machines' is the qubit. Classical bits can only hold/represent one of two
values, 0 or 1, as all information can be represented with combinations of
enough of these binary values. Qubits, on the other hand, can be thought of
as a 2-state system such as a spin-half . The state of these systems can then
be described with quantum states. A system is said to have *n* qubits if it
has a Hilbert space of :math:`N=2^n` dimensions and, thus, has :math:`2^n`
mutually orthogonal quantum states, denoted as basis states
:cite:`steane1998quantum`. The main difference with classical mechanics is
that the system, by superposition, can be in a linear combination of these
basis states, represented as unit vectors of the form
:math:`x_1=[1,0,...,0]^T`.

Therefore, a generic state :math:`\left|\psi\right>` can be defined as a
combination of the basis states
:math:`\{\left|x_1\right>,...,\left|x_N\right>\}`.

.. math::
   \left|\psi\right> = c_1\left|x_1\right>+...+c_N\left|x_N\right>

The weights of the linear combination, :math:`c_i\in\mathbb{C}`, are called
complex amplitudes or probability amplitudes. The norm square of these
defines the probability of the system being found in each of the basis states
after measurement. Because of this, the probability amplitudes need to be
normalized in order to define a proper quantum state.
A quantum state can thus be represented as its amplitude
vector :math:`[c_1,...,c_N]^T`.

The following encoding methods describe how to encode the sample data into
an amplitude vector in order to represent a quantum state. These methods
can be defined as feature maps of the form:

.. math::
   \phi: \mathcal{X} \rightarrow \mathcal{F}

Where the input :math:`x` is mapped from the input space into the feature
space.

In order to visually represent the transformations, another representation of
quantum states will be used: the Bloch sphere. This is a geometrical
representation of a qubit where its quantum state is shown as a point in the
unit sphere. The antipodal points correspond to the two basis states
:math:`\left|0\right>` and :math:`\left|1\right>`. The translation into
spherical coordinates is then made by defining the quantum state as:

.. math::
   \left|\psi\right> = c_0\left|0\right>+c_1\left|1\right> = \cos{
   \frac{\theta}{2}}\left|0\right>+e^{i\phi}\sin{\frac{\theta}{2}}
   \left|1\right>

Basis Encoding
-------------------

In basis encoding, each classical bit of a value is mapped into a single
qubit, defining the encoding feature map as:

.. math::
   \phi:i\rightarrow \left|i\right>

This means that a value :math:`x` would need :math:`\lceil\log_2 x\rceil`
qubits in order to be mapped.

The value :math:`0` would therefore be mapped to the state
:math:`\left|0\right>`.

.. GENERATED FROM PYTHON SOURCE LINES 84-94

.. code-block:: default


    from skqlearn.encoding import *
    import matplotlib.pyplot as plt
    from qiskit.quantum_info import Statevector
    import numpy as np

    data = 0
    state = Statevector(BasisEncoding().encoding(data))
    print(state.draw('text'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [1.+0.j,0.+0.j]




.. GENERATED FROM PYTHON SOURCE LINES 95-97

.. code-block:: default

    state.draw('bloch').show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_001.png
   :alt: , qubit 0
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 98-111

A value like :math:`5` would need of :math:`3` qubits for the mapping, each
one representing each bit in the binary representation of the number,
:math:`101`.

.. note::
   Quantum states defined by the state of each of its qubits, for
   example :math:`\left|011\right>`, are usually represented in little-endian
   with the first qubit in the left-most position. Qiskit, the SDK used for
   the visualization of the states, represents the qubits in big-endian.
   This means that if the state is supposed to be :math:`\left|011\right>`,
   the qubit with state :math:`\left|0\right>` will be shown by Qiskit
   in the right-most position.


.. GENERATED FROM PYTHON SOURCE LINES 111-115

.. code-block:: default

    data = 5
    state = Statevector(BasisEncoding().encoding(data))
    print(state.draw('text'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.+0.j,0.+0.j,0.+0.j,0.+0.j,0.+0.j,1.+0.j,0.+0.j,0.+0.j]




.. GENERATED FROM PYTHON SOURCE LINES 116-118

.. code-block:: default

    state.draw('bloch').show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_002.png
   :alt: , qubit 0, qubit 1, qubit 2
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 119-126

The encoding also permits encoding an entire dataset of binary strings
:math:`\mathcal{D}=\{\boldsymbol{x}^1,...,\boldsymbol{x}^m\}` together as:

.. math::
   \left|\mathcal{D}\right> = \frac{1}{\sqrt{M}}\sum_{m=1}^{M}
   \left|\boldsymbol{x}^m\right>.


.. GENERATED FROM PYTHON SOURCE LINES 126-130

.. code-block:: default

    data = np.array([0, 1, 2, 3])
    state = Statevector(BasisEncoding().encoding(data))
    print(state.draw('text'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.5+0.j,0.5+0.j,0.5+0.j,0.5+0.j]




.. GENERATED FROM PYTHON SOURCE LINES 131-134

.. code-block:: default

    state.draw('bloch').show()





.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_003.png
   :alt: , qubit 0, qubit 1
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 135-155

Amplitude Encoding
-----------------------

In amplitude encoding, each component of the input vector
:math:`\boldsymbol{x} \in \mathbb{R}^N` is mapped to an amplitude of the
quantum state, defining the encoding feature map as:

.. math::
   \phi:\boldsymbol{x}\rightarrow\left|\psi_\boldsymbol{x}\right>=
   \sum_{i=1}^{N}\frac{1}{|\boldsymbol{x}|}x_i\left|i-1\right>

In order to represent a valid quantum state, the amount of amplitudes
must be a power of 2, :math:`N=2^n`. If they are not,
they can be padded with zeros at the end.

For this encoding to generate valid quantum states, the input vectors must
be normalized. If they are not, the method is responsible for normalizing
them. This should be taken into account when planning on using this encoding.
The forceful normalization is performed because some subroutines can work
around the issue.

.. GENERATED FROM PYTHON SOURCE LINES 155-160

.. code-block:: default


    data = np.array([1 / np.sqrt(2), 1 / np.sqrt(2)])
    state = Statevector(AmplitudeEncoding().encoding(data))
    print(state.draw('text'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.70710678+0.j,0.70710678+0.j]




.. GENERATED FROM PYTHON SOURCE LINES 161-163

.. code-block:: default

    state.draw('bloch').show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_004.png
   :alt: , qubit 0
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 164-172

The input vectors can also be mapped to :math:`d` copies of the amplitude
vectors, which can be specially useful when using the kernel defined by the
encoding feature map.

.. math::
   \phi:\boldsymbol{x}\rightarrow\left|\psi_\boldsymbol{x}\right>
   ^{\bigotimes d}


.. GENERATED FROM PYTHON SOURCE LINES 172-176

.. code-block:: default

    data = np.array([1 / np.sqrt(2), 1 / np.sqrt(2)])
    state = Statevector(AmplitudeEncoding(degree=2).encoding(data))
    print(state.draw('text'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.5+0.j,0.5+0.j,0.5+0.j,0.5+0.j]




.. GENERATED FROM PYTHON SOURCE LINES 177-179

.. code-block:: default

    state.draw('bloch').show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_005.png
   :alt: , qubit 0, qubit 1
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 180-185

A dataset can also be encoded by concatenating all the resulting amplitude
vectors and normalizing.

In this case, the first 2D vector is mapped to the first qubit (or last
in Qiskit's representation) and so on.

.. GENERATED FROM PYTHON SOURCE LINES 185-190

.. code-block:: default


    data = np.array([[1/np.sqrt(2), 1/np.sqrt(2)], [1.0, 0.0]])
    state = Statevector(AmplitudeEncoding().encoding(data))
    print(state.draw('text'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.5       +0.j,0.5       +0.j,0.70710678+0.j,0.        +0.j]




.. GENERATED FROM PYTHON SOURCE LINES 191-193

.. code-block:: default

    state.draw('bloch').show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_006.png
   :alt: , qubit 0, qubit 1
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 194-202

Expanded Amplitude Encoding
--------------------------------

This encoding method tries to solve the normalization problem in regular
Amplitude Encoding. If non-normalized data is normalized for use on
Amplitude Encoding, the data will lose one dimension of information. For
example, if a 2D point is normalized, it will be mapped into the unit
circle, a 1D shape.

.. GENERATED FROM PYTHON SOURCE LINES 202-224

.. code-block:: default


    points = np.array([[1, 1],
                       [2, 2],
                       [0.5, 3]])
    normalized_points = points / np.linalg.norm(points, axis=1)[:, None]
    lines = np.array([[[p[0], n[0]], [p[1], n[1]]]
             for p, n in zip(points, normalized_points)])

    # Plot unit circle
    x = np.linspace(0, np.pi / 2, 30)
    plt.plot(np.cos(x), np.sin(x))
    # Plot encodings
    for i in range(lines.shape[0]):
        plt.plot(lines[i, 0, :], lines[i, 1, :], '--')
    plt.scatter(points[:, 0], points[:, 1], marker='o')
    plt.scatter(normalized_points[:, 0], normalized_points[:, 1], marker='x')
    plt.xlim([0, 4])
    plt.ylim([0, 4])
    plt.xlabel(r'$X_1$')
    plt.ylabel(r'$X_2$')
    plt.show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_007.png
   :alt: plot encodings
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 225-233

By adding an extra component to
:math:`\boldsymbol{x}\in\mathbb{R}^N` with a value of :math:`c`,
:math:`x_{0}=c`, and then normalizing, the information loss is mitigated.

.. math::
       \phi:\boldsymbol{x}\rightarrow\left|\psi_\boldsymbol{x}\right>=
       \frac{1}{\sqrt{|\boldsymbol{x}|^2+c^2}}\left(c\left|0\right> +
       \sum_{i=1}^{N}x_i\left|i\right>\right)

.. GENERATED FROM PYTHON SOURCE LINES 233-256

.. code-block:: default


    c = 1
    points = np.array([[1, 1, c],
                       [2, 2, c],
                       [0.5, 3, c]])
    normalized_points = points / np.linalg.norm(points, axis=1)[:, None]
    lines = np.array([[[p[0], n[0]], [p[1], n[1]]]
             for p, n in zip(points, normalized_points)])

    # Plot limits
    plt.plot([0, 1], [1, 1], 'b')
    plt.plot([1, 1], [0, 1], 'b')
    # Plot encodings
    for i in range(lines.shape[0]):
        plt.plot(lines[i, 0, :], lines[i, 1, :], '--')
    plt.scatter(points[:, 0], points[:, 1], marker='o')
    plt.scatter(normalized_points[:, 0], normalized_points[:, 1], marker='x')
    plt.xlim([0, 4])
    plt.ylim([0, 4])
    plt.xlabel(r'$X_1$')
    plt.ylabel(r'$X_2$')
    plt.show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_008.png
   :alt: plot encodings
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_008.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 257-260

As shown in the figure, now the mapping is injective because of the
mitigation of information loss. The encoding itself works exactly the same
as Amplitude Encoding.

.. GENERATED FROM PYTHON SOURCE LINES 260-265

.. code-block:: default


    data = np.array([1.0, 1.0, 1.0])
    state = Statevector(ExpandedAmplitudeEncoding(c=1.0).encoding(data))
    print(state.draw('text'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.5+0.j,0.5+0.j,0.5+0.j,0.5+0.j]




.. GENERATED FROM PYTHON SOURCE LINES 266-268

.. code-block:: default

    state.draw('bloch').show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_009.png
   :alt: , qubit 0, qubit 1
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_009.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 269-282

Angle Encoding
----------------

In angle encoding, each component of the input vector
:math:`\boldsymbol{x} \in \mathbb{R}^N` is mapped to a qubit, defining the
encoding feature map as:

.. math::
   \phi:\boldsymbol{x}\rightarrow\left|\psi_\boldsymbol{x}\right>=
   \bigotimes_{i=1}^{N}\cos{x_i}\left|0\right>+\sin{x_i}\left|1\right>

Because of the encoding feature map, the resulting quantum state is
correctly normalized and therefore valid, as :math:`\cos{x}^2+\sin{x}^2=1`.

.. GENERATED FROM PYTHON SOURCE LINES 282-287

.. code-block:: default


    data = np.array([0.0, np.pi / 4, np.pi / 2, 3 * np.pi / 4])
    state = Statevector(AngleEncoding().encoding(data))
    print(state.draw('text'))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [-3.061617e-17+0.j, 3.061617e-17+0.j,-5.000000e-01+0.j,...,
      0.000000e+00+0.j,-0.000000e+00+0.j, 0.000000e+00+0.j]




.. GENERATED FROM PYTHON SOURCE LINES 288-291

This encoding method is visualized specially well with the Bloch sphere
because it follows an almost identical definition of how the quantum states
are represented in the sphere.

.. GENERATED FROM PYTHON SOURCE LINES 291-294

.. code-block:: default


    state.draw('bloch').show()




.. image-sg:: /generated/auto_tutorials/images/sphx_glr_plot_encodings_010.png
   :alt: , qubit 0, qubit 1, qubit 2, qubit 3
   :srcset: /generated/auto_tutorials/images/sphx_glr_plot_encodings_010.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 295-311

QSample Encoding
-----------------

In QSample encoding, a discrete probability distribution is mapped into the
amplitude vector of a quantum state, defining the encoding feature map as:

.. math::
    \phi:p(x)\rightarrow \left|p(x)\right>=\sum_{X} \sqrt{p(x_i)}
    \left|x_i\right>

Because the amplitudes are defined as :math:`\alpha_i = \sqrt{p(x_i)}`,
the resulting quantum state is valid:
:math:`\sum |\alpha_i|^2=\sum p(x_i) = 1`.

This allows for the measurement of the quantum state to be interpreted as
a sampling of the discrete probability distribution.

.. GENERATED FROM PYTHON SOURCE LINES 311-315

.. code-block:: default


    data = np.array([0.25, 0.5, 0.25])
    state = Statevector(QSampleEncoding().encoding(data))
    print(state.draw('text'))




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [0.5       +0.j,0.70710678+0.j,0.5       +0.j,0.        +0.j]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  2.170 seconds)


.. _sphx_glr_download_generated_auto_tutorials_plot_encodings.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_encodings.py <plot_encodings.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_encodings.ipynb <plot_encodings.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
